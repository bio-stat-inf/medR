---
title: "Функции"
output:
  html_document:
    toc: true
    toc_float: true
    collapsed: false
    number_sections: false
    toc_depth: 1
    #code_folding: hide
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	message = FALSE,
	warning = FALSE,
	cache = TRUE
)
```

```{r packages, message=FALSE, warning=FALSE}
library(dplyr)
require(ggplot2)
```

# Векторизированные вычисления

## Векторизованные вычисления в R с использованием apply-функций

Использование оператора циклов `for()`, что характерно для языков
низкого уровня типа Basic, не считается хорошим стилем программирования
на языке R, ориентированном на векторизацию вычислений. Вместо того,
чтобы выполнять последовательно скалярные операции над каждым из
элементов массива, гораздо эффективнее выполнять параллельные
вычисления, при которых программа обрабатывает одновременно весь массив
(вектор) целиком или по несколько элементов вектора в каждый момент
времени. Очевидно, что такой подход потенциально может привести к
значительному ускорению однотипных вычислений над большими массивами
данных. Рассмотрим простейший пример векторизованных вычислений в R.
Допустим, у нас имеется вектор из 10 положительных чисел, и мы хотим
извлечь квадратный корень из каждого из них. Вместо написания цикла для
поочередного выполнения этой операции над каждым элементом, мы просто
подаем весь этот вектор на вход функции sqrt(), которая возвращает
вектор с результатами вычислений:

```{r}
x <- 1:10
sqrt(x)
```

Принцип векторизованных вычислений применим не только к векторам как
таковым, но и к более сложным объектам R - матрицам, спискам и таблицам
данных (для R разницы между последними двумя типами объектов не
существует: фактически таблица данных является списком из нескольких
компонентов - векторов одинакового размера).

В базовой комплектации R имеется целое семейство функций,
предназначенных для организации векторизованных вычислений над такими
объектами.

В названии всех этих функций имеется слово **apply** (англ. применить),
которому предшествует буква, указывающая на принцип работы той или иной
функции (см. подробнее в справочном файле `?apply`). При этом: -
`apply()` в отличии от `for()` можно легко распараллелить (просто
переименовав функцию в ее параллельную версию из пакета snow); -
алгоритмы, записанные без циклов, легче модифицируются, содержат меньше
ошибок и легче набираются в командной строке; - результат работы
`apply()` может быть аргументом функции, не говоря уже о том что любая
функция может быть вставлена в качестве аргумента в `apply()` . В ответе
на один из вопросов, опубликованных на сайте stackoverflow.com, который
мы постоянно используем для поиска информации по R, был дан
замечательный обзор apply-функций с примерами их использования. Ниже
приводится перевод этого сообщения (с некоторыми изменениями и
дополнениями).

# Функция apply()

Функция `apply()` - используется в случаях, когда необходимо применить
какую- либо функцию ко всем строкам или столбцам матрицы (или массивам
большей размерности):

> `apply(x, MARGIN, FUN, ...)`

где x - это преобразуемый объект,\
MARGIN - индекс, обозначающий направление процесса вычислений (по
столбцам или строкам),\
FUN - применяемая для вычислений функция, а\
... - это любые другие параметры применяемой функции.

Для матрицы или таблицы данных MARGIN = 1 обозначает строки, а MARGIN =
2 - столбцы. Поскольку FUN означает любую функцию R, в том числе и ту,
которую вы сами написали (см. раздел 2.7), то функция `apply()` - это
мощное средство модульной обработки данных.

```{r}
# Создадим обычную двумерную матрицу:
M <- matrix(seq(1,16), 4, 4)
# Найдем минимальные значения в каждой строке матрицы 
apply(M, 1, min)
#[1] 1 2 3 4
# Найдем минимальные значения в каждом столбце матрицы 
apply(M, 2, max)
#[1] 4 8 12 16
# Пример с трехмерным массивом:
M <- array(seq(32), dim = c(4,4,2))
# Применим функцию sum() к кадому элементу M[*, ,],
# т.е. выполним суммирование по измерениями 2 и 3: 
apply(M, 1, sum)
# Результат - одномерный вектор:
#[1] 120 128 136 144
# Применим функцию SUW()K каждому элементу M[*, *, ],
# - т.е. выполним суммирование по третьему измерению: 
apply(M, c(1,2), sum)
# Результат - матрица:
```

При необходимости вычисления сумм и средних значений по строкам или
столбцам матриц рекомендуется также использовать очень быстрые и
специально оптимизированные для этого функции `colSums()`, `rowSums()`,
`colMeans()` и `rowMeans()`.

# Функция lapply()

Функция `lapply()` - используется в случаях, когда необходимо применить
какую-либо функцию к каждому компоненту списка и получить результат
также в виде списка (буква "l" в названии `lapply()` означает list -
"список").

```{r}
# Создадим список с тремя компонентами-векторами:
x <- list(a = 1, b = 1:3, c = 10:100)
# Выясним размер каждого компонента списка х
# (функция length()):
lapply(x, FUN = length)

```

```{r}
# Выполним суммирование элементов в каждом компоненте списка х:
lapply(x, FUN = sum)
```

# Функция sapply()

Функция `sapply()` - используется в случаях, когда необходимо применить
какую-либо функцию к каждому компоненту списка, но результат вывести в
виде вектора (буква "s" в названии `sapply()` означает simplify -
"упростить").

```{r}
# Список из трех компонентов:
x <- list(a = 1, b = 1:3, c = 10:100)
# Выясним размер каждого компонента списка х:
sapply(x, FUN = length)
#a b c
#1 3 91 # результат возвращен в виде вектора
```

```{x}
x <- list(a = 1, b = 1:3, c = 10:100)
# Суммирование всех элементов в каждом компоненте списка х:
sapply(x, FUN = sum)
#a b c
#1 6 5005 # результат возвращен в виде вектора
```

В некоторых более "продвинутых" случаях `sapply()` может выдать
результат в виде многомерного массива. Например, если применяемая нами
функция возвращает векторы одинаковой длины, `sapply()` объединит эти
векторы в матрицу (по столбцам):

```{r}
sapply(1:5,function(x) rnorm(3,x))
```

Если применяемая функция возвращает матрицу, то `sapply()` преобразует
каждую матрицу в вектор и объединит такие векторы в одну большую матрицу
(звучит не очень понятно, но пример хорошо поясняет эту идею):

```{r}
sapply(1:5,function(x) matrix(x, 2, 2))
```

Поведение `sapply()`, продемонстрированное в последнем примере, можно
отменить при помощи аргумента simplify = "array" - в этом случае матрицы
будут объединены в один многомерный массив:

```{r}
sapply(1:5,function(x) matrix(x,2,2), simplify = "array")
```

# Функция replicate()

Функция `replicate()` является своего рода "оберткой" для функции
`sapply(`) и позволяет провести серию вычислений с целью генерации
набора чисел по заданному алгоритму. Синтаксис функции имеет вид:

> `replicate(n, expr, simplify=TRUE)`

где `n` - число повторов, `expr` - функция или группа выражений, которые
надо повторить `n` раз, `simplify = TRUE` - необязательный параметр,
который пробует упростить результат и представить его в виде вектора или
матрицы значений. Рассмотрим пример использования функции `replicate()`
для проверки статистической гипотезы о равенстве медиан двух выборок
бутстреп-методом (см. раздел 2.7). Созданная нами функция `boot_med()`
из каждой исходной выборки x и у извлекает по N псевдовыборок, используя
алгоритм "случайного выбора с возвратом", и находит разность их медиан.
Здесь функция `sample.int()` формирует целочисленные наборы случайных
индексов `indx` и `indy` для каждого из сравниваемых векторов:

```{r}
boot_med <- function(x, y, N=100) {
 replicate(N, {
   indx <- sample.int(length(x), length(x), replace=T) 
   indy <- sample.int(length(y), length(y), replace=T) 
   median(x[indx]) - median(y[indy])
 })
}
```

Для тестирования функции проверим однородность медиан для двух случайных
выборок из нормального распределения со средним mean=10 и стандартным
отклонением sd=4:

```{r}
Y <- rnorm(100, sd=4, mean=10)
X <- rnorm(100, sd=4, mean=10)
quantile(boot_med(Y,X,10000), probs = c(0.025, 0.975))
```

Поскольку доверительный интервал разности медиан включает 0, то нулевую
гипотезу отклонять не следует.

# Функция vapply()

Функция `vapply()` - схожа с `sapply()`, но работает несколько быстрее
за счет того, что пользователь однозначно указывает тип возвращаемых
значений (буква "v" в названии `vapply()` означает velocity -
"скорость"; пример сравнения `sapply()` и `vapply()` можно найти на
stackoverflow.com).

Такой подход позволяет также избегать сообщений об ошибках (и прерывания
вычислений), возникающих при работе с `sapply()` в некоторых ситуациях.
При вызове vapply() пользователь должен привести пример ожидаемого типа
возвращаемых значений. Для этого служит аргумент `FUN.VALUE`:

```{r}
# Аргументу FUN.VALUE присвоено логическое значение FALSE.
# Этим задается тип возвращаемых функцией значений,
# который ожидает пользователь
a <- vapply(NULL, is.factor, FUN.VALUE = FALSE)
# Функция sapply() применена к тому же NULL-объекту:
b <- sapply(NULL, is.factor)
# Проверка типа переменных:
is.logical(a)
#[1] TRUE
is.logical(b)
#[1] FALSE
```

# Функция mapply()

Функция `mapply()` - используется в случаях, когда необходимо
поэлементно применить какую-либо функцию одновременно к нескольким
объектам (например, получить сумму первых элементов векторов, затем
сумму вторых элементов векторов, и т.д.). Результат возвращается в виде
вектора или массива другой размерности (см. примеры для `sapply()`
выше). Буква "m" в названии `mapply()` означает multivariate -
"многомерный" (имеется в виду одновременное выполнение вычислений над
элементами нескольких объектов).

```{r}
mapply(sum, 1:5, 1:5, 1:5)
#[1] 3 6 9 12 15
```

# Функция rapply()

Функция `rapply()` - используется в случаях, когда необходимо применить
какую-либо функцию к компонентам вложенного списка (буква "r" в названии
`rapply()` означает recursively - "рекурсивно").

```{r}
# Пользовательская функция, которая добавляет ! к элементу
# объекта x если этот элемент является текстовым выражением
# или добавляет 1 если этот элемент является числом: 
myFun <- function (x){
   if (is.character(x)){
   return(paste(x,"!",sep=""))
   }
   else {
   return(x + 1)
   }
}
```

```{r}
# Пример вложенного списка:
l <- list(a = list(a1 = "Boo", b1 = 2, c1 = "Eeek"),
          b = 3, c = "Yikes",
          d = list(a2 = 1, b2 = list(a3 = "Hey", b3 = 5)))
l 
```

```{r}
# Рекурсивное применение функции myFun к списку l:
rapply(l,myFun)

```

Если необходимо вернуть результат в виде вложенного списка, можно
воспользоваться аргументом `how = "replace"`. В этом случае исходные
значения в списке `l` будут заменены на новые:

```{r}
rapply(l, myFun, how = "replace")
```

# Функция tapply()

Функция `tapply()` - используется в случаях, когда необходимо применить
какую-либо функцию fun к отдельным группам элементов вектора x, заданным
в соответствии с уровнями какого-либо фактора group:

> 'tapply(x, group, fun, ...)'

Например, в следующем фрагменте кода функция sample() используется для
создания двух случайных выборок: из 50 значений целых чисел от 1 до 4 и
связанных с ними меток четырех групп A-D. Функция tapply() подсчитывает
суммы х для каждого из значений фактора:

```{r}
x <- sample(1:4, size=50, replace=T)
gr <- as.factor(sample(c("A","B","C","D"), size=50, replace=T))
tapply(x, gr,sum)
```

Другие примеры использования `tapply()` мы приведем позднее в разделе,
посвященном расчету параметров описательной статистики.

## Функция by()

Функция `by()` является своего рода аналогом функции `tapply()`, с той
разницей, что она применяется для таблиц. Таблица `data` разделяется в
соответствии с заданным столбцом-фактором group на подмножество
подтаблиц и для обработки каждой такой части определяется функция `fun`:

> `by(data, group, fun, ...)`

Рассмотрим пример с таблицей Моллюски, представленной в разделе 1.3, и
рассчитаем средние значения длины раковины `ZMlength` и численности
инфузорий `CAnumber` для каждого из трех обследованных озер `Lake`
(Баторино, Мястро и Нарочь):

```{r}
#Моллюски <-
#read.table("http://figshare.com/media/download/98923/97987",
#header=TRUE, sep="\t", na.strings="NA", strip.white=TRUE)
#by(Моллюски[,4:5], Моллюски$Lake, colMeans)
```

# Функция outer()

Функция `outer(`) позволяет выполнить комбинаторную операцию fun над
элементами двух массивов или векторов x и у, не прибегая к явному
использованию "двойного" цикла:

> `outer(x, у, fun="*", ...)`

По умолчанию осуществляется операция попарного перемножения

```{r}
х <- 1:5; у <-1:5
outer(х,у)
```

Используя, например, функцию `outer()` вместе с функцией `paste()`,
можно сгенерировать все возможные попарные комбинации "связок" элементов
символьного и целочисленного векторов:

```{r}
х <- c("А", "В", "С", "D")
у <- 1:10
outer(x, у, paste, sep="")
```
