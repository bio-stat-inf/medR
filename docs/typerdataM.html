<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Типы данных R (М)</title>

<script src="site_libs/header-attrs-2.18/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Медицинский R</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Главная</a>
</li>
<li>
  <a href="Journal.html">Содержание</a>
</li>
<li>
  <a href="Links.html">Ссылки</a>
</li>
<li>
  <a href="intro_r.html">Введение в R</a>
</li>
<li>
  <a href="typerdata.html">Типы данных</a>
</li>
<li>
  <a href="typerdataM.html">Типы данных (доп.)</a>
</li>
<li>
  <a href="apply_f.html">Векторизация</a>
</li>
<li>
  <a href="freq_r.html">Частоты</a>
</li>
<li>
  <a href="learnr_page/learnr_page.html">Задания</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Типы данных R (М)</h1>

</div>


<pre class="r"><code>library(dplyr)
require(ggplot2)</code></pre>
<div id="типы-данных-языка-r" class="section level1">
<h1>Типы данных языка R</h1>
<p>Все объекты данных (а, следовательно, и переменные) в R можно
разделить на следующие классы (т.е. типы объектов):</p>
<p><strong>numeric</strong> – объекты, к которым относятся целочисленные
(<code>integer</code>) и действительные числа (<code>double</code>);</p>
<p><strong>logical</strong> – логические объекты, которые принимают
только два значения: <code>FALSE</code> (сокращенно <code>F</code>) и
<code>TRUE</code> (<code>T</code>);</p>
<p><strong>character</strong> – символьные объекты (значения переменных
задаются в двойных, либо одинарных кавычках).</p>
<p>В R можно создавать имена для различных объектов (функций или
переменных) как на латинице, так и на кириллице, но следует учесть, что
а (кириллица) и а (латиница) - это два разных объекта.</p>
<p>Кроме того, среда R чувствительна к регистру, т.е. строчные и
заглавные буквы в ней различаются. Имена переменных (идентификаторы) в R
должны начинаться с буквы (или точки <code>.</code>) и состоять из букв,
цифр, знаков точки и подчёркивания. При помощи команды
<code>? &lt;имя&gt;</code> можно проверить, существует ли переменная или
функция с указанными именем. Проверка на принадлежность переменной к
определенному классу проверяется функциями
<code>is.numeriс(&lt;имя_объекта&gt;)</code>,
<code>is.integer(&lt;имя&gt;)</code>,
<code>is.logical(&lt;имя&gt;)</code>,
<code>is.character(&lt;имя&gt;)</code>, а для преобразования объекта в
другой тип можно использовать функции
<code>as.numeric(&lt;имя&gt;)</code>,
<code>as.integer(&lt;имя&gt;)</code>,
<code>as.logical(&lt;имя&gt;)</code>,
<code>as.character(&lt;имя&gt;)</code>.</p>
<p>В R существует ряд специальных объектов:</p>
<ul>
<li><code>Inf</code> - положительная или отрицательная бесконечность
(обычно результат деления вещественного числа на 0);</li>
<li><code>NA</code> - “отсутствующее значение” (Not Available);</li>
<li><code>NaN</code> - “не число” (Not a Number).</li>
</ul>
<p>Проверить, относится ли переменная к какому-либо из этих специальных
типов, можно, соответственно, функциями
<code>is.finite(&lt;имя&gt;)</code>, <code>is.na(&lt;имя&gt;)</code> и
<code>is.nan(&lt;имя&gt;)</code>.</p>
<p><strong>Выражение</strong> (expression) языка R представляет собой
сочетание таких элементов, как оператор присваивания, арифметические или
логические операторы, имена объектов и имена функций. Результат
выполнения выражения, как правило, сразу отображается в командном или
графическом окне. Однако при выполнении операции присваивания результат
сохраняется в соответствующем объекте и на экран не выводится.</p>
<p>В качестве оператора присваивания в R можно использовать либо символ
<code>"="</code>, либо пару символов <code>"&lt;-"</code> (присваивание
определенного значения объекту слева) или <code>"-&gt;"</code>
(присваивание значения объекту справа). Хорошим стилем программирования
считается использование <code>"&lt;-"</code>.</p>
<p>Выражения языка R организуются в скрипте по строкам. В одной строке
можно ввести несколько команд, разделяя их символом <code>";"</code>.
Одну команду можно также расположить на двух (и более) строках. Объекты
типа <code>numeric</code> могут составлять выражения с использованием
традиционных арифметических операций</p>
<p><code>+</code> (сложение),<br />
<code>-</code> (вычитание),<br />
<code>*</code> (умножение),<br />
<code>/</code> (деление),<br />
<code>^</code> (возведение в степень),<br />
<code>%/%</code> (целочисленное деление),<br />
<code>%%</code> (остаток от деления).</p>
<p>Операции имеют обычный приоритет, т.е. сначала выполняется возведение
в степень, затем умножение или деление, потом уже сложение или
вычитание. В выражениях могут использоваться круглые скобки и операции в
них имеют наибольший приоритет.</p>
<p><strong>Логические выражения</strong> могут составляться с
использованием следующих логических операторов:</p>
<p>“Равно” <code>==</code> °<br />
“Не равно” <code>! =</code> °<br />
“Меньше” <code>&lt;</code> °<br />
“Больше” <code>&gt;</code> °<br />
“Меньше либо равно” <code>&lt;=</code> °<br />
“Больше либо равно” <code>&gt;=</code> °<br />
“Логическое И” <code>&amp;</code> °<br />
“Логическое ИЛИ” <code>|</code> °<br />
“Логическое НЕ” <code>!</code></p>
</div>
<div id="векторы-и-матрицы" class="section level1">
<h1>Векторы и матрицы</h1>
<p><strong>Вектор</strong> представляет собой поименованный одномерный
объект, содержащий набор однотипных элементов (числовые, логические,
либо текстовые значения - никакие их сочетания не допускаются). Для
создания векторов небольшой длины в R используется функция конкатенации
<code>c()</code> (от “concatenate” - объединять, связывать). В качестве
аргументов этой функции через запятую перечисляют объединяемые в вектор
значения, например:</p>
<pre class="r"><code>my.vector &lt;- c(1, 2, 3, 4, 5) 
my.vector</code></pre>
<pre><code>## [1] 1 2 3 4 5</code></pre>
<p>Вектор можно создать также при помощи функции <code>scan()</code>,
которая “считывает” последовательно вводимые с клавиатуры значения:</p>
<pre class="r"><code>X &lt;- scan() </code></pre>
<p>После каждого нового значения нажать клавишу “Ввод”</p>
<p>1: 2.9<br />
2: 3.1<br />
3: 3.4<br />
4: 3.4<br />
5: 3.7<br />
6: 3.7<br />
7: 2.8<br />
8: 2.5<br />
9: #</p>
<p>Выполнение команды <code>scan</code> завершают введением пустой
строки. Программа сообщает о считывании 8 значений.</p>
<pre class="r"><code>X</code></pre>
<pre><code>## numeric(0)</code></pre>
<p>Один из недостатков создания векторов при помощи функции
<code>scan()</code> состоит в том, что если при вводе значений с
клавиатуры допущена ошибка, то приходится, либо начать ввод заново, либо
воспользоваться специальными инструментами корректировки (например,
функцией <code>fix()</code>; здесь эти способы не рассматриваются). Для
создания векторов, содержащих последовательную совокупность чисел,
удобна функция <code>seq()</code> (от “sequence” - последовательность).
Так, вектор с именем <code>S</code>, содержащий совокупность целых чисел
от 1 до 7, можно создать следующим образом:</p>
<pre class="r"><code>S &lt;- seq(1,7) 
S</code></pre>
<pre><code>## [1] 1 2 3 4 5 6 7</code></pre>
<p>Идентичный результат будет получен при помощи команды</p>
<pre class="r"><code>S &lt;- 1:7 
S</code></pre>
<pre><code>## [1] 1 2 3 4 5 6 7</code></pre>
<p>В качестве дополнительного аргумента функции <code>seq()</code> можно
задать шаг приращения чисел:</p>
<pre class="r"><code>S &lt;- seq(from = 1, to = 5, by = 0.5) 
S</code></pre>
<pre><code>## [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0</code></pre>
<p>Векторы, содержащие одинаковые значения, создают при помощи функции
<code>rep()</code> (от “repeat” - повторять). Например, для формирования
текстового вектора <code>Text</code>, содержащего пять значений “test”,
следует выполнить команду</p>
<pre class="r"><code>Text &lt;- rep(&quot;test&quot;, 5) 
Text</code></pre>
<pre><code>## [1] &quot;test&quot; &quot;test&quot; &quot;test&quot; &quot;test&quot; &quot;test&quot;</code></pre>
<p>Система R способна выполнять самые разнообразные операции над
векторами. Так, несколько векторов можно объединить в один, используя
уже рассмотренную выше функцию конкатенации:</p>
<pre class="r"><code>v1 &lt;- c(1, 2, 3) 
v2 &lt;- c(4, 5, 6) 
V &lt;- c(v1, v2) 
V</code></pre>
<pre><code>## [1] 1 2 3 4 5 6</code></pre>
<p>Если попытаться объединить, например, текстовый вектор с числовым,
сообщение об ошибке не появится - программа просто преобразует все
значения в текстовые:</p>
<pre class="r"><code># создаем текстовый вектор text.vect:
text.vect &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
# объединяем числовой вектор v1 (см. выше)
# с текстовым вектором text.vect:
new.vect &lt;- c(v1, text.vect)
# просмотр содержимого нового вектора new.vect:
new.vect</code></pre>
<pre><code>## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot;</code></pre>
<pre class="r"><code># все значения нового вектора взяты в кавычки,
# что указывает на их текстовую природу;
# для подтверждения этого воспользуемся командой mode(): 
mode(new.vect)</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<pre class="r"><code># все верно: &quot;character&quot; значит &quot;текстовый&quot;</code></pre>
<p>Для работы c определенным элементом вектора необходимо иметь способ
отличать его от других элементов. Для этого при создании вектора всем
его компонентам автоматически присваиваются индексные номера, начиная с
1. Чтобы обратится к конкретному элементу необходимо указать имя вектора
и индекс этого элемента в квадратных скобках:</p>
<pre class="r"><code># создадим числовой вектор у, содержащий 5 числовых значений:
y &lt;- c(5, 3, 2, 6, 1)
# проверим, чему равен третий элемент вектора у:
y[3]</code></pre>
<pre><code>## [1] 2</code></pre>
<p>Используя индексные номера, можно выполнять различные операции с
избранными элементами разных векторов:</p>
<pre class="r"><code># создадим еще один числовой вектор z, содержащий 3 значения:
z &lt;- c(0.5, 0.1, 0.6)
# умножим первый элемент вектора у на третий элемент вектора z
# (т.е. 5*0.6):
y[1]*z[3]</code></pre>
<pre><code>## [1] 3</code></pre>
<p>Индексирование является мощным инструментом, позволяющим создавать
совокупности значений в соответствии с определенными критериями.
Например, для вывода на экран 3-го, 4-го и 5-го значений вектора у
необходимо выполнить команду</p>
<pre class="r"><code>y[3:5]</code></pre>
<pre><code>## [1] 2 6 1</code></pre>
<p>Из этого же вектора мы можем выбрать, например, только первое и
четвертое значения, используя уже известную нам функцию конкатенации
<code>с()</code>:</p>
<pre class="r"><code>y[c(1, 4)]</code></pre>
<pre><code>## [1] 5 6</code></pre>
<p>Похожим образом мы можем удалить первое и четвертое значения из
вектора <code>у</code>, применив знак “минус” перед функцией
конкатенации:</p>
<pre class="r"><code>y[-c(1, 4)]</code></pre>
<pre><code>## [1] 3 2 1</code></pre>
<p>В качестве критерия для выбора значений может служить логическое
выражение. Для примера выберем из вектора у все значения
<code>&gt; 2</code>:</p>
<pre class="r"><code>y[y&gt;2]</code></pre>
<pre><code>## [1] 5 3 6</code></pre>
<p>Индексирование является также удобным инструментом для внесения
исправлений в имеющихся векторах. Например, так можно исправить второе
значение созданного нами ранее вектора <code>z</code> с 0.1 на 0.3:</p>
<pre class="r"><code>z[2] &lt;- 0.3
z</code></pre>
<pre><code>## [1] 0.5 0.3 0.6</code></pre>
<p>Для упорядочения значений вектора по возрастанию или убыванию
используют функцию <code>sort()</code> в сочетании с аргументом
<code>decreasing = FALSE</code> или <code>decreasing = TRUE</code>
соответственно (“decreasing” значит “убывающий”):</p>
<pre class="r"><code>sort(z) # по умолчанию decreasing = FALSE</code></pre>
<pre><code>## [1] 0.3 0.5 0.6</code></pre>
<pre class="r"><code>sort(z, decreasing = TRUE)</code></pre>
<pre><code>## [1] 0.6 0.5 0.3</code></pre>
<p>Матрица представляет собой двумерный вектор. В R для создания матриц
служит одноименная функция:</p>
<pre class="r"><code>my.mat &lt;- matrix(seq(1, 16), nrow = 4, ncol = 4)
my.mat</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    1    5    9   13
## [2,]    2    6   10   14
## [3,]    3    7   11   15
## [4,]    4    8   12   16</code></pre>
<p>Обратите внимание на то, что по умолчанию заполнение матрицы
происходит по столбцам, т.е. первые четыре значения входят в первый
столбец, следующие четыре значения - во второй столбец, и т.д. Такой
порядок заполнения можно изменить, придав специальному аргументу
<code>byrow</code> (от “by row” - по строкам) значение
<code>TRUE</code>:</p>
<pre class="r"><code>my.mat &lt;- matrix(seq(1, 16), nrow = 4, ncol = 4, byrow = TRUE)
my.mat</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    1    2    3    4
## [2,]    5    6    7    8
## [3,]    9   10   11   12
## [4,]   13   14   15   16</code></pre>
<p>В качестве заголовков строк и столбцов создаваемой матрицы
автоматически выводятся соответствующие индексные номера (строки: [1,],
[2,], и т.д.; столбцы: [,1], [,2], и т.д.). Для придания
пользовательских заголовков строкам и столбцам матриц используют функции
<code>rownames()</code> и <code>colnames()</code> соответственно.
Например, для обозначения строк матрицы my.mat буквами A, B, C и D
необходимо выполнить следующее:</p>
<pre class="r"><code>rownames(my.mat) &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;)
my.mat</code></pre>
<pre><code>##   [,1] [,2] [,3] [,4]
## A    1    2    3    4
## B    5    6    7    8
## C    9   10   11   12
## D   13   14   15   16</code></pre>
<p>В матрице <code>my.mat</code> имеется 16 значений, которые как раз
вмещаются в имеющиеся четыре строки и четыре столбца. Но что произойдет,
если, например, попытаться вместить вектор из 12 чисел в матрицу того же
размера? В подобных случаях R заполняет недостающие значения за счет
“зацикливания” (recycling) короткого вектора. Вот как это выглядит на
примере:</p>
<pre class="r"><code>my.mat2 &lt;- matrix(seq(1, 12), nrow = 4, ncol = 4, byrow = TRUE)
my.mat2</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    1    2    3    4
## [2,]    5    6    7    8
## [3,]    9   10   11   12
## [4,]    1    2    3    4</code></pre>
<p>Как видим, для заполнения ячеек последней строки матрицы
<code>my.mat2</code> программа снова использовала числа 1, 2, 3, и 4.
Альтернативный способ создания матриц заключается в применении функции
<code>dim()</code> (от “dimension” - размерность). Так, матрицу
<code>my.mat</code> мы могли бы сформировать из одномерного вектора
следующим образом:</p>
<pre class="r"><code>my.mat &lt;- 1:16
# Задаем размерность 4x4 вектору my.mat:
dim(my.mat) &lt;- c(4,4)</code></pre>
<pre class="r"><code># Функция очень полезна. Она позволяет проверить размерность уже имеющейся матрицы (или таблицы данных):
dim(my.mat)</code></pre>
<pre><code>## [1] 4 4</code></pre>
<p>Матрицу можно собрать также из нескольких векторов, используя функции
<code>cbind()</code> (от colum и bind - столбец и связывать) или
<code>rbind()</code> (от row и bind - строка и связывать):</p>
<pre class="r"><code># Создадим четыре вектора одинаковой длины:
a &lt;- c(1,2,3,4)
b &lt;- c(5,6,7,8)
c &lt;- c(9,10,11,12)
d &lt;- c(13,14,15,16)
# Объединим этим векторы при помощи функции cbind():
cbind (a,b,c,d)</code></pre>
<pre><code>##      a b  c  d
## [1,] 1 5  9 13
## [2,] 2 6 10 14
## [3,] 3 7 11 15
## [4,] 4 8 12 16</code></pre>
<pre class="r"><code># Объединим те же векторы при помощи функции rbind():
rbind(a, b, c, d)</code></pre>
<pre><code>##   [,1] [,2] [,3] [,4]
## a    1    2    3    4
## b    5    6    7    8
## c    9   10   11   12
## d   13   14   15   16</code></pre>
<p>Практически все векторные операции одинаково применимы в отношении
матриц и массивов. Так, путем индексирования мы можем извлекать из
матриц необходимые элементы и далее подвергать их требуемым
преобразованиям. Рассмотрим лишь несколько примеров:</p>
<pre class="r"><code>#Извлечем элемент матрицы my.mat, расположенный на
#пересечении 2-й строки и 3-го столбца:
my.mat[2, 3]</code></pre>
<pre><code>## [1] 10</code></pre>
<pre class="r"><code>#Извлечем из матрицы все элементы, находящиеся в 4-м столбце
#(для этого номера строк перед запятой можно не указывать): 
my.mat[, 4]</code></pre>
<pre><code>## [1] 13 14 15 16</code></pre>
<pre class="r"><code>#Извлечем из матрицы все элементы, находящиеся в 1-й строке
#(в этом случае нет необходимости указывать номера столбцов): 
my.mat[1, ]</code></pre>
<pre><code>## [1]  1  5  9 13</code></pre>
<pre class="r"><code># Перемножим 1-й и 4-й столбцы матрицы (поэлементно):
my.mat[,1]*my.mat[,4]</code></pre>
<pre><code>## [1] 13 28 45 64</code></pre>
<p>Отметим, наконец, что при необходимости матрицу можно транспонировать
(т.е. поменять местами строки и столбцы) при помощи функции
<code>t()</code> (от transpose):</p>
<pre class="r"><code>t(my.mat)</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    1    2    3    4
## [2,]    5    6    7    8
## [3,]    9   10   11   12
## [4,]   13   14   15   16</code></pre>
</div>
<div id="факторы" class="section level1">
<h1>Факторы</h1>
<p>Предположим, что в эксперименте по испытанию эффективности нового
медицинского препарата было задействовано 10 пациентов-добровольцев, из
которых шесть пациентов принимали новый препарат, а четверо остальных -
плацебо (например, таблетки активированного угля). Для обозначения
членов этих двух групп мы можем использовать коды 1 (препарат) и 0
(плацебо). Соответственно, информацию о всех десяти участниках
эксперимента мы могли бы сохранить в виде следующего вектора:</p>
<pre class="r"><code>treatment &lt;- c(1, 1, 1, 1, 1, 1, 0, 0, 0, 0) 
treatment</code></pre>
<pre><code>##  [1] 1 1 1 1 1 1 0 0 0 0</code></pre>
<p>При таком подходе, однако, программа будет “рассматривать” вектор
treatment в качестве числового (проверьте при помощи команды
<code>class(treatment)</code>). Это будет ошибкой с нашей стороны,
поскольку ноль и единица обозначают лишь два уровня номинальной
переменной. С таким же успехом мы могли бы использовать, например, 10
для обозначения контрольной группы пациентов (т.е. пациентов,
принимавших плацебо) и 110 для обозначения пациентов, принимавших
испытываемый препарат. Для преобразования числового (или текстового)
вектора в фактор в R существует одноименная функция
<code>factor()</code>:</p>
<pre class="r"><code>treatment &lt;- factor(treatment, levels = c(0, 1)) 
treatment</code></pre>
<pre><code>##  [1] 1 1 1 1 1 1 0 0 0 0
## Levels: 0 1</code></pre>
<p>Обратите внимание на то, что теперь при выводе содержимого объекта
treatment программа подсказывает нам, что этот объект является фактором
с двумя уровнями (<code>Levels: 0 1</code>). Дополнительно убедиться в
этом можно при помощи все той же команды class(treatment):</p>
<pre class="r"><code>class(treatment)</code></pre>
<pre><code>## [1] &quot;factor&quot;</code></pre>
<p>Более надежным подходом, позволяющим не запутаться при выполнении
анализа, является кодировка уровней факторов при помощи текстовых
значений, а не чисел. Например, в нашем примере можно присвоить значение
yes пациентам, принимавшим препарат, и значение no пациентам из
контрольной группы. Мы можем перекодировать уровни уже имеющегося
фактора treatment при помощи функции <code>levels()</code>:</p>
<pre class="r"><code>levels(treatment) &lt;- c(&quot;no&quot;, &quot;yes&quot;) 
treatment</code></pre>
<pre><code>##  [1] yes yes yes yes yes yes no  no  no  no 
## Levels: no yes</code></pre>
<p>Заметьте, что при выводе содержимого вектора <code>treatment</code>
коды пациентов не заключены в двойные кавычки, как это обычно бывает в
случае с текстовыми значениями. Это является одним из внешних признаков
того, что мы имеем дело именно с фактором, а не с текстовым вектором,
содержащим шесть значений “<code>yes</code>” и четыре значения
“<code>no</code>”. Те же факторы легко преобразовать обратно в числовой
вектор, состоящий из порядковых номеров уровней факторов:</p>
<pre class="r"><code>as.numeric(treatment)</code></pre>
<pre><code>##  [1] 2 2 2 2 2 2 1 1 1 1</code></pre>
<p>Существует также специальная команда для создания факторов:</p>
<blockquote>
<p><code>gl(n, k, length = n*k, labels = 1:n)</code> ,</p>
</blockquote>
<p>где <code>n</code> - количество уровней фактора; <code>k</code> -
число повторов для каждого уровня; <code>length</code> - размер
итогового объекта; <code>labels</code> - необязательный аргумент,
который можно использовать для указания названий каждого уровня
фактора.</p>
<p>Например, выполнение следующей команды приведет к созданию вектора
<code>my.fac</code>, являющегося фактором с двумя уровнями - Control и
Treatment, причем каждая из меток “Control” и “Treatment” будет
повторена по 8 раз:</p>
<pre class="r"><code>my.fac = gl(2, 8, labels = c(&quot;Control&quot;, &quot;Treatment&quot;)) 
my.fac</code></pre>
<pre><code>##  [1] Control   Control   Control   Control   Control   Control   Control  
##  [8] Control   Treatment Treatment Treatment Treatment Treatment Treatment
## [15] Treatment Treatment
## Levels: Control Treatment</code></pre>
<p>Еще одна полезная команда создает факторы, разделив область вариации
числового вектора <code>x</code> на интервалы:</p>
<blockquote>
<p><code>cut(x, breaks, labels)</code></p>
</blockquote>
<p>где в качестве аргумента <code>breaks</code> может выступать либо
необходимое число интервалов, либо вектор, содержащий список “точек
разрыва”, а <code>labels</code> определяет названия уровней:</p>
<pre class="r"><code>x &lt;- c(1,2,3,4,5,2,3,4,5,6,7)
cut(x, breaks=3)</code></pre>
<pre><code>##  [1] (0.994,3] (0.994,3] (0.994,3] (3,5]     (3,5]     (0.994,3] (0.994,3]
##  [8] (3,5]     (3,5]     (5,7.01]  (5,7.01] 
## Levels: (0.994,3] (3,5] (5,7.01]</code></pre>
<pre class="r"><code>cut(x, breaks=3, labels = letters[1:3])</code></pre>
<pre><code>##  [1] a a a b b a a b b c c
## Levels: a b c</code></pre>
<pre class="r"><code>cut(x,breaks=quantile(x,c(0,.25,.50,.75,1)),
labels=c(&quot;Q1&quot;,&quot;Q2&quot;,&quot;Q3&quot;,&quot;Q4&quot;),include.lowest=TRUE)</code></pre>
<pre><code>##  [1] Q1 Q1 Q2 Q2 Q3 Q1 Q2 Q2 Q3 Q4 Q4
## Levels: Q1 Q2 Q3 Q4</code></pre>
<p>В третьем фрагменте кода числовой вектор “разрезан” по квартильным
значениям, а параметр <code>include.lowest</code> указан, чтобы избежать
появления неопределенности “<code>NA</code>” для значения
<code>х = 1</code>.</p>
</div>
<div id="списки-и-таблицы-данных" class="section level1">
<h1>Списки и таблицы данных</h1>
<p>#Списки и таблицы В отличие от вектора или матрицы, которые могут
содержать данные только одного типа, в список (list) или таблицу (data
frame) можно включать сочетания любых типов данных. Это позволяет
эффективно, т.е. в одном объекте, хранить разнородную информацию.</p>
<p>Каждый компонент списка может являться переменной, вектором,
матрицей, фактором или другим списком. Кроме того, эти элементы могут
принадлежать к различным типам: числа, строки символов, булевы
переменные. Списки являются наиболее общим средством хранения
внутрисистемной информации: в частности, результаты большинства
статистических анализов в программе R хранятся в объектах- списках. Для
создания списков в R служит одноименная функция <code>list()</code>.
Рассмотрим пример:</p>
<pre class="r"><code># Сначала создадим три разнотипных вектора - с текстовыми,
# числовыми и логическими значениями:
vector1 &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)
vector2 &lt;- seq(1, 3, 0.5)
vector3 &lt;- c(FALSE, TRUE)
# Теперь объединим эти три вектора в один объект-список,
# компонентам которого присвоим имена Text, Number и Logic: 
my.list &lt;- list(Text=vector1, Number=vector2, Logic=vector3)
# Просмотрим содержимое созданного списка:
my.list</code></pre>
<pre><code>## $Text
## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot;
## 
## $Number
## [1] 1.0 1.5 2.0 2.5 3.0
## 
## $Logic
## [1] FALSE  TRUE</code></pre>
<p>К элементам списка можно получить доступ посредством трех различных
операций индексации. Для обращения к поименованным компонентам применяют
знак <code>$</code>. Так, для извлечения компонентов <code>Text</code>,
<code>Number</code> и <code>Logic</code> из созданного нами списка
<code>y.list</code> необходимо последовательно ввести следующие
команды:</p>
<pre class="r"><code>my.list$Text</code></pre>
<pre><code>## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot;</code></pre>
<pre class="r"><code>my.list$Number</code></pre>
<pre><code>## [1] 1.0 1.5 2.0 2.5 3.0</code></pre>
<pre class="r"><code>my.list$Logic</code></pre>
<pre><code>## [1] FALSE  TRUE</code></pre>
<p>Имеется возможность извлекать из списка не только его поименованные
компоненты-векторы, но и отдельные элементы, входящие в эти векторы. Для
этого необходимо воспользоваться уже рассмотренным ранее способом -
индексацией при помощи квадратных скобок. Единственная особенность
работы со списками здесь состоит в том, что сначала необходимо указать
имя компонента списка, используя знак <code>$</code>, а уже затем
номер(а) отдельных элементов этого компонента:</p>
<pre class="r"><code>my.list$Text[2]</code></pre>
<pre><code>## [1] &quot;B&quot;</code></pre>
<pre class="r"><code>my.list$Number[3:5]</code></pre>
<pre><code>## [1] 2.0 2.5 3.0</code></pre>
<pre class="r"><code>my.list$Logic[1]</code></pre>
<pre><code>## [1] FALSE</code></pre>
<p>Извлечение компонентов списка можно осуществлять также с
использованием двойных квадратных скобок, в которые заключается номер
компонента списка:</p>
<pre class="r"><code>my.list[[1]]</code></pre>
<pre><code>## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot;</code></pre>
<pre class="r"><code>my.list[[2]]</code></pre>
<pre><code>## [1] 1.0 1.5 2.0 2.5 3.0</code></pre>
<pre class="r"><code>my.list[[3]]</code></pre>
<pre><code>## [1] FALSE  TRUE</code></pre>
<p>После двойных квадратных скобок с индексным номером компонента списка
можно также указать номер(а) отдельных элементов этого компонента:</p>
<pre class="r"><code>my.list[[1]][2]</code></pre>
<pre><code>## [1] &quot;B&quot;</code></pre>
<pre class="r"><code>my.list[[2]][3:5]</code></pre>
<pre><code>## [1] 2.0 2.5 3.0</code></pre>
<pre class="r"><code>my.list[[3]][1]</code></pre>
<pre><code>## [1] FALSE</code></pre>
<p>Созданный нами список <code>my.list</code> содержал всего лишь три
небольших вектора, и мы знали, какие это векторы, и на каком месте в
списке они стоят. Однако на практике можно столкнуться с гораздо более
сложно организованными списками, индексирование которых может быть
затруднено из-за отсутствия представлений об их структуре. Для выяснения
структуры объектов в языке R имеется специальная функция
<code>str()</code> (от structure):</p>
<pre class="r"><code>str(my.list)</code></pre>
<pre><code>## List of 3
##  $ Text  : chr [1:3] &quot;A&quot; &quot;B&quot; &quot;C&quot;
##  $ Number: num [1:5] 1 1.5 2 2.5 3
##  $ Logic : logi [1:2] FALSE TRUE</code></pre>
<p>Из приведенного примера следует, что список <code>my.list</code>
включает 3 компонента (List of 3) с именами <code>Text</code>,
<code>Number</code> и <code>Logic</code> (перечислены в отдельных
строках после знака <code>$</code>).</p>
<p>Эти компоненты относятся к символьному (<code>chr</code>), числовому
(<code>num</code>) и логическому (<code>logic</code>) типам векторов
соответственно.</p>
<p>Кроме того, команда <code>str()</code> выводит на экран первые
несколько элементов каждого вектора. Таблица данных (data frame)
представляет собой объект R, по структуре напоминающий лист электронной
таблицы Microsoft Excel.</p>
<p>Каждый столбец таблицы является вектором, содержащим данные
определенного типа. При этом действует правило, согласно которому все
столбцы должны иметь одинаковую длину (собственно, с “точки зрения” R
таблица данных является частным случаем списка, в котором все
компоненты- векторы имеют одинаковый размер).</p>
<p>Таблицы данных - это основной класс объектов R, используемых для
хранения данных. Обычно такие таблицы подготавливаются при помощи
внешних приложений (особенно популярна и удобна программа Microsoft
Excel) и затем загружаются в среду R. Подробнее об импортировании данных
в R будет рассказано ниже. Тем не менее, небольшую таблицу можно собрать
из нескольких векторов средствами самой системы R. Для этого используют
функцию <code>data.frame()</code>. Предположим, у нас есть наблюдения по
общей численности мужского (Male) и женского (Female) населения в трех
городах <code>City1</code>, <code>City2</code>, и <code>City3</code>.
Представим эти данные в виде одной таблицы с именем <code>CITY</code>.
Для начала создадим текстовые векторы с названиями городов
(<code>city</code>) и пола (<code>sex</code>), а также вектор со
значениями численности представителей каждого пола
(<code>number</code>):</p>
<pre class="r"><code>city &lt;- c(&quot;City1&quot;, &quot;City1&quot;, &quot;City2&quot;, &quot;City2&quot;, &quot;City3&quot;, &quot;City3&quot;) 
sex &lt;- c(&quot;Male&quot;, &quot;Female&quot;, &quot;Male&quot;, &quot;Female&quot;, &quot;Male&quot;, &quot;Female&quot;) 
number &lt;- c(12450, 10345, 5670, 5800, 25129, 26000)</code></pre>
<p>Теперь объединим эти три вектора в одну таблицу данных и посмотрим,
что получилось:</p>
<pre class="r"><code>CITY &lt;- data.frame(City = city, Sex = sex, Number = number) 
CITY</code></pre>
<pre><code>##    City    Sex Number
## 1 City1   Male  12450
## 2 City1 Female  10345
## 3 City2   Male   5670
## 4 City2 Female   5800
## 5 City3   Male  25129
## 6 City3 Female  26000</code></pre>
<p>Обратите внимание на синтаксис функции <code>data.frame()</code>: ее
аргументы перечисляются в формате “заголовок столбца = добавляемый
вектор”. В качестве заголовков столбцов могут выступать любые
пользовательские имена, удовлетворяющие требованиям R (см. об этом
подробнее в разделе 2.1). Извлечь отдельные компоненты таблиц для
выполнения необходимых вычислений, как и в примерах со списками, можно с
использованием знака <code>$</code>, квадратных скобок с указанием двух
индексов [<code>&lt;номер_строки&gt;</code>,
<code>&lt;номер_столбца&gt;</code>], двойных квадратных скобок
<code>[[]]</code>, либо непосредственно по имени столбца:</p>
<pre class="r"><code>CITY$Sex</code></pre>
<pre><code>## [1] &quot;Male&quot;   &quot;Female&quot; &quot;Male&quot;   &quot;Female&quot; &quot;Male&quot;   &quot;Female&quot;</code></pre>
<pre class="r"><code>CITY$Number</code></pre>
<pre><code>## [1] 12450 10345  5670  5800 25129 26000</code></pre>
<pre class="r"><code># Идентичные результаты можно получить при помощи команд: CITY[,2]
CITY[[3]]</code></pre>
<pre><code>## [1] 12450 10345  5670  5800 25129 26000</code></pre>
<pre class="r"><code>CITY[&quot;Sex&quot;]</code></pre>
<pre><code>##      Sex
## 1   Male
## 2 Female
## 3   Male
## 4 Female
## 5   Male
## 6 Female</code></pre>
<pre class="r"><code>CITY[&quot;Number&quot;]</code></pre>
<pre><code>##   Number
## 1  12450
## 2  10345
## 3   5670
## 4   5800
## 5  25129
## 6  26000</code></pre>
<p>После имени или индексного номера столбца можно указывать индексные
номера отдельных ячеек таблицы, что позволяет извлекать содержимое этих
ячеек:</p>
<pre class="r"><code># Извлекаем 4-й элемент из столбца Number:
CITY$Number[4]</code></pre>
<pre><code>## [1] 5800</code></pre>
<pre class="r"><code># Извлекаем элементы 1-3 из столбца Number:
CITY$Number[1:3]</code></pre>
<pre><code>## [1] 12450 10345  5670</code></pre>
<pre class="r"><code># Извлекаем все значения численности, превышающие 10000
CITY$Number[CITY$Number &gt; 10000]</code></pre>
<pre><code>## [1] 12450 10345 25129 26000</code></pre>
<pre class="r"><code># Извлекаем все значения численности мужского населения:
CITY$Number[CITY$Sex == &quot;Male&quot;]</code></pre>
<pre><code>## [1] 12450  5670 25129</code></pre>
<pre class="r"><code># Повторяем те же команды, но с использованием []:
CITY[4, 3]</code></pre>
<pre><code>## [1] 5800</code></pre>
<pre class="r"><code>CITY[1:3, 3]</code></pre>
<pre><code>## [1] 12450 10345  5670</code></pre>
<pre class="r"><code>CITY[CITY$Number &gt;10000, 3]</code></pre>
<pre><code>## [1] 12450 10345 25129 26000</code></pre>
<pre class="r"><code>CITY[CITY$Sex == &quot;Male&quot;, 3]</code></pre>
<pre><code>## [1] 12450  5670 25129</code></pre>
<p>При работе с большими таблицами данных бывает сложно визуально
исследовать всё их содержимое перед началом анализа. Однако визуального
просмотра содержимого таблиц и не требуется - полную сводную информацию
о них (равно как и о других объектах R) можно легко получить при помощи
упомянутой ранее функции <code>str()</code> :</p>
<pre class="r"><code>str(CITY)</code></pre>
<pre><code>## &#39;data.frame&#39;:    6 obs. of  3 variables:
##  $ City  : chr  &quot;City1&quot; &quot;City1&quot; &quot;City2&quot; &quot;City2&quot; ...
##  $ Sex   : chr  &quot;Male&quot; &quot;Female&quot; &quot;Male&quot; &quot;Female&quot; ...
##  $ Number: num  12450 10345 5670 5800 25129 ...</code></pre>
<p>Как следует из представленного отчета, объект <code>CITY</code>
является таблицей данных, в состав которой входят три переменные с
шестью наблюдениями каждая. Две из этих переменных - <code>City</code> и
<code>Sex</code> - программа автоматически распознала как факторы с
тремя и двумя уровнями соответственно. Переменная <code>Number</code>
является количественной. Для удобства выводятся также несколько первых
значений каждой переменной. Часто возникает необходимость выяснить лишь
имена переменных, входящих в таблицу данных. Это можно сделать при
помощи команды <code>names()</code>:</p>
<pre class="r"><code>names(CITY)</code></pre>
<pre><code>## [1] &quot;City&quot;   &quot;Sex&quot;    &quot;Number&quot;</code></pre>
<p>Имеется также возможность быстро просмотреть несколько первых или
несколько последних значений каждой переменной, входящей в состав
таблицы данных. Для этого используются функции <code>head()</code> и
<code>tail()</code> соответственно:</p>
<pre class="r"><code>head(CITY, n = 3)</code></pre>
<pre><code>##    City    Sex Number
## 1 City1   Male  12450
## 2 City1 Female  10345
## 3 City2   Male   5670</code></pre>
<pre class="r"><code>tail(CITY, n = 2)</code></pre>
<pre><code>##    City    Sex Number
## 5 City3   Male  25129
## 6 City3 Female  26000</code></pre>
<p>При необходимости внесения исправлений в таблицу можно
воспользоваться встроенным в R редактором данных. Внешне этот редактор
напоминает обычный лист Excel, однако имеет весьма ограниченные
функциональные возможности. Все, что он позволяет делать - это добавлять
новые или исправлять уже введенные значения переменных, изменять
заголовки столбцов, а также добавлять новые строки и столбцы. Работая в
стандартной версии R, редактор данных можно запустить из меню “Файлы
&gt; Редактор данных”, либо выполнив команду <code>fix()</code> (fix -
исправлять, чинить) из командной строки консоли R (например,
<code>fix(CITY)</code>). После внесения исправлений редактор просто
закрывают - все изменения будут сохранены автоматически.</p>
<p>#Заполнение пустых значений Часто на практике некоторые значения в
таблице отсутствуют, что может быть обусловлено множеством причин: на
момент измерения прибор вышел из строя, по невнимательности персонала
измерение не было занесено в протокол исследования, испытуемый отказался
отвечать на определенный вопрос(ы) в анкете, была утеряна проба, и т.п.
Ячейки с такими отсутствующими значениями (missing values) в таблицах
данных R не могут быть просто пустыми - иначе столбцы таблицы окажутся
разной длины. Для обозначения отсутствующих наблюдений в языке R, как
указывалось ранее, имеется специальное значение - NA (not available - не
доступно). В разделе 4.4 мы остановимся на решении проблемы заполнения
пропусков подробнее. Здесь же отметим, что если значение NA имеет смысл
нуля (например, экземпляров некого вида обнаружено не было), то легко
произвести эту замену в таблице DF командой</p>
<p><code>DF[is.na(DF)] &lt;- 0</code></p>
</div>
<div id="сортировка-таблиц" class="section level1">
<h1>Сортировка таблиц</h1>
<p>Сортировка строк таблицы по различным ключам не представляет труда.
Для этого используется функция order():</p>
<pre class="r"><code>DF &lt;- data.frame(X1=c(1,15,1,3), X2=c(1,0,7,0), X3=c(1,0,1,2), X4=c(7,4,41,0), X5=c(1,0,5,3))
row.names(DF) &lt;- c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;)
#   DF1 - таблица, столбцы которой отсортированы
#   по убыванию суммы значений
DF1 &lt;- DF[, rev(order(colSums(DF)))]
#   DF2 - таблица, строки которой отсортированы в восходящем
#   порядке по 1 столбцу, затем в нисходящем по второму
DF2 &lt;- DF[order(DF$X1, -DF$X2), ]</code></pre>
</div>
<div id="объединение-таблиц" class="section level1">
<h1>Объединение таблиц</h1>
<p>Пусть мы имеем две таблицы:</p>
<p>DF1</p>
<pre class="r"><code>DF1 &lt;- data.frame(Y=c(12,12,12), N=c(22,23,24), A=c(0,1,0), B=c(1,3,0),C=c(0,0,1))
DF1</code></pre>
<pre><code>##    Y  N A B C
## 1 12 22 0 1 0
## 2 12 23 1 3 0
## 3 12 24 0 0 1</code></pre>
<table>
<thead>
<tr class="header">
<th>Y</th>
<th>N</th>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>12</td>
<td>22</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="even">
<td>12</td>
<td>23</td>
<td>1</td>
<td>3</td>
<td>0</td>
</tr>
<tr class="odd">
<td>12</td>
<td>24</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>DF2</p>
<pre class="r"><code>DF2 &lt;- data.frame(Y=c(13,13,13), N=c(22,23,24), A=c(0,0,1), B=c(1,3,0),D=c(2,0,1))
DF2</code></pre>
<pre><code>##    Y  N A B D
## 1 13 22 0 1 2
## 2 13 23 0 3 0
## 3 13 24 1 0 1</code></pre>
<table>
<thead>
<tr class="header">
<th>Y</th>
<th>N</th>
<th>A</th>
<th>B</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>13</td>
<td>22</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr class="even">
<td>13</td>
<td>23</td>
<td>0</td>
<td>3</td>
<td>0</td>
</tr>
<tr class="odd">
<td>13</td>
<td>24</td>
<td>1</td>
<td>0</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>Объединить их столбцы можно с использованием известной нам
функции:</p>
<pre class="r"><code>cbind(DF1,DF2)</code></pre>
<pre><code>##    Y  N A B C  Y  N A B D
## 1 12 22 0 1 0 13 22 0 1 2
## 2 12 23 1 3 0 13 23 0 3 0
## 3 12 24 0 0 1 13 24 1 0 1</code></pre>
<p>Для объединения строк мы должны предварительно преобразовать
объединяемые таблицы к единому списку столбцов:</p>
<pre class="r"><code>DF1[,names(DF2)[!(names(DF2) %in% names(DF1))]] &lt;- NA
DF2[,names(DF1)[!(names(DF1) %in% names(DF2))]] &lt;- NA
rbind(DF1,DF2)</code></pre>
<pre><code>##    Y  N A B  C  D
## 1 12 22 0 1  0 NA
## 2 12 23 1 3  0 NA
## 3 12 24 0 0  1 NA
## 4 13 22 0 1 NA  2
## 5 13 23 0 3 NA  0
## 6 13 24 1 0 NA  1</code></pre>
<p>Аналогичную операцию мы можем выполнить с помощью команды</p>
<pre class="r"><code>merge(DF1, DF2,all = TRUE)</code></pre>
<pre><code>##    Y  N A B  C  D
## 1 12 22 0 1  0 NA
## 2 12 23 1 3  0 NA
## 3 12 24 0 0  1 NA
## 4 13 22 0 1 NA  2
## 5 13 23 0 3 NA  0
## 6 13 24 1 0 NA  1</code></pre>
<p>Функция <code>merge()</code> позволяет выполнять объединение таблиц
всеми распространенными способами join-операций языка SQL.</p>
</div>
<div id="импортирование-данных-в-r" class="section level1">
<h1>Импортирование данных в R</h1>
<p>В предыдущих разделах было рассмотрено, как, работая непосредственно
в системе R, можно создать небольшие по объему объекты для хранения
данных (векторы, матрицы, списки, таблицы данных).</p>
<p>Следует отметить, однако, что возможности системы R по вводу и
редактированию данных умышленно ограничены ее создателями, которые
предполагали, что для этого будут использоваться другие средства
(например, программа Microsoft Excel или базы данных). Поэтому
подлежащие анализу объемные таблицы данных обычно подготавливаются при
помощи сторонних приложений, и только потом загружаются в рабочую среду
R из внешних файлов. Хотя предпочтение при этом отдается текстовым
файлам, выше был упомянут специальный пакет <code>foreign</code>,
функции которого позволяют импортировать таблицы, сохраненные во
множестве других распространенных форматов (Excel, SPSS, SAS, STAT A,
Access, Matlab, SQL, Oracle, и т.п.; см. также руководство R Data
Import/Export).</p>
<p>Импортирование данных в систему R часто вызывает проблемы у тех, кто
только начинает работать с этой программой. Тем не менее, ничего
сложного в этом нет. Ниже будут подробно рассмотрены наиболее
распространенные способы импорта таблиц данных в рабочую среду R, однако
сначала стоит ознакомиться с правилами подготовки загружаемых
файлов:</p>
<ul>
<li>В импортируемой таблице с данными не должно быть пустых ячеек. Если
некоторые значения по тем или иным причинам отсутствуют, вместо них
следует ввести NA.</li>
<li>Импортируемую таблицу с данными рекомендуется преобразовать в
простой текстовый файл с одним из допустимых расширений. На практике
обычно используются файлы с расширением .txt, в которых значения
переменных разделены знаками табуляции (tab-delimited files), а также
файлы с расширением .csv (comma separated values), в которых значения
переменных разделены запятыми или другим разделяющим символом.</li>
<li>В качестве первой строки в импортируемой таблице рекомендуется
ввести заголовки столбцов-переменных. Такая строка - удобный, но не
обязательный элемент загружаемого файла. Если она отсутствует, то об
этом необходимо сообщить в описании команды, которая будет управлять
загрузкой файла (например, <code>read.table()</code> - см. ниже). Все
последующие строки файла в качестве первого элемента могут содержать
заголовки строк (если таковые предусмотрены), после которых следуют
значения каждой из имеющихся в таблице переменных.</li>
</ul>
<p>Имена столбцов таблицы лучше присвоить с соблюдением правил
идентификации переменных R, т.е. исключить пробелы и другие специальные
символы, кроме точки и подчеркивания. Во избежание проблем, связанных с
кодировкой, все текстовые величины в импортируемых файлах стоит
создавать с использованием букв латинского алфавита. Подлежащий
импортированию файл рекомендуется поместить в рабочую папку программы,
т.е. папку, в которой R по умолчанию будет “пытаться найти” этот файл
(см. раздел 1.1). Чтобы выяснить путь к рабочей папке R на своем
компьютере используйте команду <code>getwd()</code> (get working
directory - узнать рабочую директорию); например:</p>
<pre class="r"><code>getwd()</code></pre>
<pre><code>## [1] &quot;C:/Users/Work/Documents/GitHub/medR&quot;</code></pre>
<pre class="r"><code>#[1] &quot;C:/Temp/&quot;</code></pre>
<p>Изменить рабочую директорию можно при помощи команды
<code>setwd()</code> (set working directory - создать рабочую
директорию):</p>
<pre class="r"><code>#setwd(&quot;C:/My Documents&quot;)</code></pre>
<p>При выполнении этой команды внешне ничего не произойдет, однако
последующее применение команды <code>getwd()</code> покажет, что путь к
рабочей папке изменился:</p>
<pre class="r"><code>getwd()</code></pre>
<pre><code>## [1] &quot;C:/Users/Work/Documents/GitHub/medR&quot;</code></pre>
<pre class="r"><code>#[1] &quot;C:/My Documents/&quot;</code></pre>
<p>Ниже приведен фрагмент типичной таблицы данных, которая может быть
успешно загружена для анализа в среду R:</p>
<pre class="r"><code>Name&lt;-c(&quot;Ivan&quot;, &quot;Vitaliy&quot;, &quot;Sergey&quot;, &quot;Mikhail&quot;)
Group&lt;-c(&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;)
Variable1&lt;-c(102,98,45,50)
Variable2&lt;-c(1.3,1.4,NA,3.2)
Variable3&lt;-c(14,11,8,6)
df &lt;- data.frame(Name, Group, Variable1, Variable2, Variable3)
print (df)</code></pre>
<pre><code>##      Name Group Variable1 Variable2 Variable3
## 1    Ivan     A       102       1.3        14
## 2 Vitaliy     A        98       1.4        11
## 3  Sergey     B        45        NA         8
## 4 Mikhail     B        50       3.2         6</code></pre>
<p>Как видим, приведенный фрагмент имеет размерность 5x5, т.е. состоит
из пяти строк и пяти столбцов. В первой строке представлены заголовки
всех имеющихся в таблице столбцов, за исключением первого. Первый
столбец,хотя и не имеет собственного заголовка, не является пустым - он
содержит имена добровольцев, участвовавших в некотором эксперименте
(<code>Ivan</code>, <code>Vitaliy</code> и т.д.). Второй столбец имеет
заголовок <code>Group</code> и содержит метки, по которым можно выяснить
принадлежность испытуемых к той или иной экспериментальной группе
(<code>A</code>, <code>B</code> и т.д.). Мы уже знаем, что в терминах
языка R переменная <code>Group</code> называется фактором. В последующих
столбцах (с заголовками <code>Variable1</code>, <code>Variable2</code> и
т.д.) содержатся значения измеренные в ходе исследования переменных. В
приведенном фрагменте таблицы имеется одно отсутствующее значение,
вместо которого введено <code>NA</code>. Пожалуй, одним из наиболее
доступных и удобных средств подготовки данных для их последующего
анализа при помощи R является программа Microsoft Excel. Для сохранения
Excel-таблиц в виде txt- или csv-файлов обычно предлагают использовать
опцию <strong>Сохранить как</strong> (Save as) в разделе
<strong>Файл</strong> (File) главного меню этой программы. Другим
простым и надежным способом экспорта данных из Excel является создание в
редакторе <strong>Блокнот</strong> (Notepade) нового файла и перенос
туда через буфер обмена всей таблицы или выделенной ее части. Основной
функцией для импортирования данных в рабочую среду R является
<code>read.table()</code>. Эта мощная функция позволяет достаточно тонко
настроить процесс загрузки внешних файлов, в связи с чем, она имеет
большое количество управляющих аргументов. Наиболее важные из этих
аргументов перечислены ниже в таблице (подробнее см. файл помощи,
доступный по команде <code>?read.table</code>).</p>
<table>
<colgroup>
<col width="26%" />
<col width="73%" />
</colgroup>
<thead>
<tr class="header">
<th>Аргумент</th>
<th>Назначение</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>file</strong></td>
<td>Служит для указания пути к импортируемому файлу. Путь приводят либо
в абсолютном виде (например, <code>file = "C:/Temp/MyData. dat"</code>),
либо указывают только имя импортируемого файла (например,
<code>file = "MyData.txt"</code>), но при условии, что последний
хранится в рабочей папке программы (см. выше). В качестве имени можно
также указывать полную URL-ссылку на файл, который предполагается
загрузить из Сети (например:
<code>file = "&lt;http://somesite.net/YourData.csv&gt;"</code>). Начиная
с версии R 2.10, появилась возможность импортировать архивированные
файлы в zip-формате.</td>
</tr>
<tr class="even">
<td><strong>header</strong></td>
<td>Служит для сообщения программе о наличии в загружаемом файле строки
с заголовками столбцов. По умолчанию принимает значение
<code>FALSE</code>. Если строка с заголовками столбцов имеется, этому
аргументу следует присвоить значение <code>TRUE</code>.</td>
</tr>
<tr class="odd">
<td><strong>row.names</strong></td>
<td>Служит для указания номера столбца, в котором содержатся имена строк
(например, в рассмотренном выше примере это был первый столбец, поэтому
<code>row.names = 1</code>). Важно помнить, что все имена строк должны
быть уникальными, т.е. одинаковые имена для двух или более строк не
допускаются.</td>
</tr>
<tr class="even">
<td><strong>sep</strong></td>
<td>Служит для указания разделителя значений переменных, используемого в
файле (separator - разделитель). По умолчанию предполагается, что
значения переменных разделены “пустым пространством”, например, в виде
пробела или знака табуляции (<code>sep = ""</code>). В файлах формата
csv значения переменных разделены запятыми, и поэтому для них
<code>sep =","</code>.</td>
</tr>
<tr class="odd">
<td><strong>dec</strong></td>
<td>Служит для указания знака, используемого в файле для отделения целой
части числа от дроби. По умолчанию <code>dec = "."</code>. Однако во
многих странах в качестве десятичного знака применяют запятую, о чем
важно вспомнить перед загрузкой файла и, при необходимости, использовать
<code>dec = ","</code>. Следите, чтобы <code>dec</code> и
<code>sep</code> не были бы одинаковыми.</td>
</tr>
<tr class="even">
<td><strong>nrows</strong></td>
<td>Выражается целым числом, указывающим количество строк, которое
должно быть считано из загружаемой таблицы. Отрицательные и иные
значения игнорируются. Пример: <code>nrows = 100</code>.</td>
</tr>
<tr class="odd">
<td><strong>skip</strong></td>
<td>Выражается целым числом, указывающим количество строк в файле,
которое должно быть пропущено перед началом импортирования. Пример:
<code>skip = 5</code></td>
</tr>
</tbody>
</table>
<p>Для загрузки тщательно подготовленных файлов (см. правила выше)
достаточно использовать минимальный набор аргументов функции
<code>read.table()</code>. В качестве примера предположим, что нам
необходимо загрузить файл hydro_chem.txt, который хранится в рабочей
папке R и содержит данные по химическому составу воды некоторого
водоема. Загружаемую таблицу данных мы намерены сохранить в виде объекта
с именем chem. Функции <code>read.table()</code> в этом случае может
быть применена следующим образом:</p>
<pre class="r"><code>#chem &lt;- read.table(file = &quot;hydro_chem.txt&quot;, header = TRUE)</code></pre>
<p>Как отмечено выше, импортируемые в R файлы часто имеют формат
<code>csv</code>. Для их загрузки можно воспользоваться той же функцией
<code>read.table()</code>, но при этом следует указать символ, который
используется в качестве разделителя значений переменных в файле
(например, запятая):</p>
<pre class="r"><code>#chem &lt;- read.table(file = &quot;hydro_chem.csv&quot;, header = TRUE, sep = &quot;,&quot;)</code></pre>
<p>Аналогом read.table() для считывания csv-файлов является функция
read.csv():</p>
<pre class="r"><code>#chem &lt;- read.csv(file = &quot;hydro_chem.csv&quot;, header = TRUE)</code></pre>
<p>Если подлежащий загрузке файл хранится в папке, отличной от рабочей
папки R, то следует указать полный путь к нему. При этом пользователям
операционной системы Windows необходимо помнить, что для указания полных
путей к файлам в программе R используется не обратный одинарный слэш
(<code>\</code>), а прямой одинарный (<code>/</code>) либо двойной
обратный слеш (<code>\\</code>). Например, следующие две команды будут
успешно восприняты R и приведут к идентичному результату - загрузке
файла hydro_chem.txt и сохранению его в виде объекта chem:</p>
<pre class="r"><code>#chem &lt;- read.csv(file = &quot;D:\\Documents\\hydrochem.txt&quot;, header = TRUE) 
#chem &lt;- read.csv(file = &quot;D:/Documents/hydrochem.txt&quot;, header = TRUE)</code></pre>
<p>Для интерактивного выбора загружаемого файла, который хранится вне
рабочей папки R, можно применить вспомогательную функцию
<code>file.choose()</code> (выбрать файл). Выполнение этой команды
приводит к открытию обычного диалогового окна операционной системы
Windows, в котором пользователь выбирает папку с необходимым файлом.
Очень удобно совмещать file.choose() с командами
<code>read.table()</code> или <code>read.csv()</code>, например:</p>
<pre class="r"><code>#chem &lt;- read.table(file = file.choose(), header = TRUE, sep = &quot;,&quot;)</code></pre>
<p>#Представление даты и времени; временные ряды Форматы представления
даты и времени Анализ данных, содержащих даты и время, может иногда
сопровождаться приличной головной болью. Причин этому несколько: *
разные годы начинаются в разные дни недели; * високосные годы имеют
дополнительный день в феврале; * американцы и европейцы по разному
представляют даты (например, 8/9/2011 будет 9-м августа 2011 г. для
первых и 8-м сентября 2011 г. для вторых); * в некоторые годы
добавляется так называемая “секунда координации”; * страны различаются
по временным поясам и в ряде случаев применяют переход на “зимнее” и
“летнее” время. К счастью, система дат и времени в R такова, что многие
из указанных проблем относительно легко преодолеваются. С форматом
представления дат и времени в R можно ознакомиться, выполнив команду</p>
<pre class="r"><code>Sys.time()</code></pre>
<pre><code>## [1] &quot;2022-12-03 21:48:11 MSK&quot;</code></pre>
<pre class="r"><code>#[1] &quot;2011-09-06 00:38:04 EEST&quot;</code></pre>
<p>Как видим, формат строго иерархичен: сначала идет наиболее крупная
временная единица - год, потом месяц и день, разделенные дефисом, а
затем пробел, час, минуты, секунды и, после еще одного пробела,
аббревиатура временной шкалы. Отдельные элементы из этого результата
можно извлечь при помощи функции substr() (от substring - часть строки),
указав позиции первого и последнего элементов извлекаемой строки:</p>
<pre class="r"><code>substr(as.character(Sys.time()), 1, 10)</code></pre>
<pre><code>## [1] &quot;2022-12-03&quot;</code></pre>
<p>Или</p>
<pre class="r"><code>substr(as.character(Sys.time()), 12, 19)</code></pre>
<pre><code>## [1] &quot;21:48:11&quot;</code></pre>
<p>Функция <code>date()</code> позволяет выяснить текущую дату. Если
выполнить команду:</p>
<pre class="r"><code>unclass (Sys.time())</code></pre>
<pre><code>## [1] 1670093291</code></pre>
<pre class="r"><code>###[1] 1315258719</code></pre>
<p>то получим время в формате <code>POSIXct</code>, т.е. выраженное в
секундах, прошедших с 1 января 1970 г. (его еще трактуют как Unix-время,
по названию операционной системы). Такой “машинный” формат удобен для
включения в таблицы данных. Для человека более удобным является
представление времени в формате класса <code>POSIXlt</code>. Объекты
этого класса представляют собой списки, включающие такие элементы, как
секунды, минуты, часы, дни, месяцы, и годы. Например, мы можем
конвертировать системное время в объект POSIXlt класса следующим
образом:</p>
<pre class="r"><code>date &lt;- as.POSIXlt(Sys.time())</code></pre>
<p>Из списка date далее легко можно извлечь такие содержащиеся в нем
элементы, как sec (секунды), min (минуты), hour (часы), mday (день
месяца), mon (месяц), year (год), wday (день недели, начиная с
воскресенья = 0), yday (день года, начиная с 1 января = 0), и isdst (“is
daylight savings time in operation?” - логическая переменная,
обозначающая, используется ли режим перехода на “зимнее” и “летнее”
время: 1 если TRUE и 0 если FALSE), например:</p>
<pre class="r"><code>date$wday </code></pre>
<pre><code>## [1] 6</code></pre>
<pre class="r"><code>#[1] 2 
date$yday </code></pre>
<pre><code>## [1] 336</code></pre>
<pre class="r"><code>#[1] 248</code></pre>
<p>Для просмотра всего содержимого списка date можно использовать
функцию <code>unclass()</code> в сочетании с <code>unlist()</code>:</p>
<pre class="r"><code>unlist(unclass(date))</code></pre>
<pre><code>##                sec                min               hour               mday 
## &quot;11.5441510677338&quot;               &quot;48&quot;               &quot;21&quot;                &quot;3&quot; 
##                mon               year               wday               yday 
##               &quot;11&quot;              &quot;122&quot;                &quot;6&quot;              &quot;336&quot; 
##              isdst               zone             gmtoff 
##                &quot;0&quot;              &quot;MSK&quot;            &quot;10800&quot;</code></pre>
<p>#Вычисления с датами и временем</p>
<p>В R можно выполнять следующие типы вычислительных операций с датами и
временем: * число + время; * время - число; * время 1 - время2 * время1
“логический оператор” время2 (в качестве логического оператора могут
использоваться ==, ! =, &lt;=, &lt;, &gt; или &gt;=).</p>
<p>Важной особенностью является то, что перед выполнением любых
вычислений с датами или временем необходимо конвертировать их в объекты
класса <code>POSIXlt</code>. Например, количество дней между 15 сентября
2011 г. и 15 сентября 2000 года можно найти следующим образом:</p>
<pre class="r"><code>t1 &lt;- as.POSIXlt(&quot;2011-09-15&quot;)
t2 &lt;- as.POSIXlt(&quot;2000-09-15&quot;) 
t1 - t2</code></pre>
<pre><code>## Time difference of 4017 days</code></pre>
<pre class="r"><code>#Time difference of 4017 days</code></pre>
<p>Разницу во времени, выраженную в часах, можно рассчитать так:</p>
<pre class="r"><code>t3&lt;-as.POSIXlt(&quot;2010-09-22 08:30:30&quot;)
t4&lt;-as.POSIXlt(&quot;2010-09-22 22:25:30&quot;)
t4-t3</code></pre>
<pre><code>## Time difference of 13.91667 hours</code></pre>
<pre class="r"><code>#Time difference of 13.91667 hours</code></pre>
<p>Еще проще разницу между двумя датами можно найти при помощи готовой
функции <code>difftime()</code> (от difference - разница, и time -
время):</p>
<pre class="r"><code>difftime(&quot;2011-09-22&quot;, &quot;2010-06-22&quot;)</code></pre>
<pre><code>## Time difference of 457 days</code></pre>
<pre class="r"><code>#Time difference of 457 days</code></pre>
<p>Чтобы извлечь непосредственно количество дней из результата
выполнения предыдущей команды используйте функцию
<code>as.numeric()</code>:</p>
<pre class="r"><code>as.numeric(difftime(&quot;2011-09-22&quot;, &quot;2010-06-22&quot;))</code></pre>
<pre><code>## [1] 457</code></pre>
<pre class="r"><code>#[1] 457</code></pre>
<p>Обратите внимание: в R отсутствует возможность для сложения двух дат.
Измерить продолжительность какого-нибудь вычислительного процесса можно
с использованием функции “процессорного времени”
<code>proc.time()</code>, которая, по существу, работает как секундомер:
вы засекаете стартовое время, запускаете процесс и, после его
завершения, находите разность времен. Например, чтобы вычислить 10 000
значений арктангенса, потребуется 0.02 сек.:</p>
<pre class="r"><code>t1 &lt;- proc.time()
for (x in 1:10000) y &lt;- atan(x)
time.result &lt;- proc.time() - t1
time.result[&quot;elapsed&quot;]</code></pre>
<pre><code>## elapsed 
##    0.01</code></pre>
</div>
<div id="извлечение-датывремени-из-текстовых-переменных"
class="section level1">
<h1>Извлечение даты/времени из текстовых переменных</h1>
<p>Функция <code>strptime()</code> (от strip - раздевать, оголять, и
time - время) позволяет извлекать даты и время из различных текстовых
выражений. При этом важно верно указать формат (при помощи аргумента
<code>format</code>), в котором приведены временные величины. Приняты
следующие условные обозначения для наиболее часто используемых форматов
дат и времени (детали доступны по команде <code>?strptime</code>):</p>
<p><code>%a</code> - сокращенное название для недели (англ. яз.)
<code>%A</code> - полное название для недели (англ. яз.) <code>%b</code>
- сокращенное название месяца (англ. яз.) <code>%B</code> - полное
название месяца (англ. яз.) <code>%d</code> - день месяца (01-31)
<code>%H</code> - часы от 00 до 23 <code>%I</code> - часы от 01 до 12
<code>%j</code> - порядковый номер дня года (001-366) <code>%m</code> -
порядковый номер месяца (01-12) <code>%M</code> - минуты (00-59)
<code>%S</code> - секунды (00-61, с возможностью добавить “високосную
секунду”) <code>%U</code> - неделя года (00-53), первое вокресенье
считается первым днем первой недели <code>%w</code> - порядковый номер
дня недели (0-6, воскресенье - 0) <code>%W</code> - неделя года (00-53),
первый понедельник считается первым днем первой недели <code>%Y</code> -
год с указанием века <code>%y</code> - год без указания века</p>
<p>Рассмотрим пример. Предположим, у нас имеется текстовый вектор, в
котором хранятся даты в формате программы Microsoft Excel:</p>
<pre class="r"><code>dates.excel &lt;- c(&quot;25/02/2008&quot;, &quot;24/04/2009&quot;, &quot;14/06/2009&quot;, &quot;25/07/2010&quot;, &quot;04/03/2011&quot;)</code></pre>
<p>Формат имеющихся Excel-дат таков, что сначала идет день месяца, затем
порядковый номер самого месяца и, наконец, год с указанием века.
Требуется преобразовать эти текстовые выражения в даты формата R.
Используя приведенные выше обозначения форматов функции
<code>strptime()</code>, параметр format можно представить в виде
<code>%d/%m/%Y</code>. Тогда команда для преобразования Excel-дат в
R-даты будет выглядеть следующим образом:</p>
<pre class="r"><code>strptime(dates.excel, format = &quot;%d/%m/%Y&quot;)</code></pre>
<pre><code>## [1] &quot;2008-02-25 MSK&quot; &quot;2009-04-24 MSD&quot; &quot;2009-06-14 MSD&quot; &quot;2010-07-25 MSD&quot;
## [5] &quot;2011-03-04 MSK&quot;</code></pre>
<p>Вот еще один пример, в котором год приведен без указания века, а
месяцы приведены в виде их сокращенных названий:</p>
<pre class="r"><code>example2 &lt;- c(&quot;1jan79&quot;, &quot;2jan99&quot;, &quot;31jan04&quot;, &quot;30aug05&quot;)
#strptime(other.dates, &quot;%d%b%y&quot;)
#[1] &quot;1979-01-01&quot; &quot;1999-01-02&quot; &quot;2004-01-31&quot; &quot;2005-08-30&quot;</code></pre>
<p>#Временные ряды В R существует специальный класс объектов для работы
с данными, представляющими собой временные ряды - <code>ts</code> (от
time series - временной ряд). Для создания объектов этого класса служит
одноименная функция ts(). В качестве примера рассмотрим ежемесячные
данные по рождаемости в г. Нью- Йорк, собранные в период с января 1946
г. по декабрь 1959 г. Пример заимстован из электронной книги A Little
Book of R for Time Series и исходные данные можно загрузить с сайта
проф. Роба Хиндмана (Rob J. Hyndman) следующим образом:</p>
<pre class="r"><code>birth &lt;-
scan(&quot;http://robjhyndman.com/tsdldata/data/nybirths.dat&quot;)</code></pre>
<p>Объект birth представляет собой вектор со всеми 168 ежемесячными
значениями рождаемости (в тыс. человек), в чем можно убедиться при
помощи функции:</p>
<pre class="r"><code>is.vector(birth)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>#[1] TRUE</code></pre>
<p>Функция <code>head()</code> позволяет просмотреть первые несколько
значений вектора <code>birth</code> (по умолчанию первые 6
значений):</p>
<pre class="r"><code>head(birth)</code></pre>
<pre><code>## [1] 26.663 23.598 26.931 24.740 25.806 24.364</code></pre>
<pre class="r"><code>#[1] 26.663 23.598 26.931 24.740 25.806 24.364</code></pre>
<p>Преобразовать объект <code>birth</code> во временной ряд очень
просто:</p>
<pre class="r"><code>birth.ts &lt;- ts(birth, start = c(1946, 1), frequency = 12)</code></pre>
<p>В приведенной команде аргумент <code>start</code> был использован для
того, чтобы указать дату, с которой начинается временной ряд
<code>birth.ts</code> (1946 год, 1-й месяц). Дополнительный аргумент
<code>frequency</code> (частота) позволяет задать шаг приращения
последующих дат - в рассматриваемом примере год разбивается на 12
промежутков, так что шаг приращения составляет 1 месяц. Созданный таким
образом объект <code>birth.ts</code> при просмотре внешне напоминает
матрицу. При этом строкам и столбцам этой матрицы были автоматически,
исходя из значений аргументов <code>start</code> и
<code>frequency</code>, присвоены соответствующие имена (данные по
столбцам Oct, Nov, Dec для экономии места опущены):</p>
<pre class="r"><code>birth.ts</code></pre>
<pre><code>##         Jan    Feb    Mar    Apr    May    Jun    Jul    Aug    Sep    Oct
## 1946 26.663 23.598 26.931 24.740 25.806 24.364 24.477 23.901 23.175 23.227
## 1947 21.439 21.089 23.709 21.669 21.752 20.761 23.479 23.824 23.105 23.110
## 1948 21.937 20.035 23.590 21.672 22.222 22.123 23.950 23.504 22.238 23.142
## 1949 21.548 20.000 22.424 20.615 21.761 22.874 24.104 23.748 23.262 22.907
## 1950 22.604 20.894 24.677 23.673 25.320 23.583 24.671 24.454 24.122 24.252
## 1951 23.287 23.049 25.076 24.037 24.430 24.667 26.451 25.618 25.014 25.110
## 1952 23.798 22.270 24.775 22.646 23.988 24.737 26.276 25.816 25.210 25.199
## 1953 24.364 22.644 25.565 24.062 25.431 24.635 27.009 26.606 26.268 26.462
## 1954 24.657 23.304 26.982 26.199 27.210 26.122 26.706 26.878 26.152 26.379
## 1955 24.990 24.239 26.721 23.475 24.767 26.219 28.361 28.599 27.914 27.784
## 1956 26.217 24.218 27.914 26.975 28.527 27.139 28.982 28.169 28.056 29.136
## 1957 26.589 24.848 27.543 26.896 28.878 27.390 28.065 28.141 29.048 28.484
## 1958 27.132 24.924 28.963 26.589 27.931 28.009 29.229 28.759 28.405 27.945
## 1959 26.076 25.286 27.660 25.951 26.398 25.565 28.865 30.000 29.261 29.012
##         Nov    Dec
## 1946 21.672 21.870
## 1947 21.759 22.073
## 1948 21.059 21.573
## 1949 21.519 22.025
## 1950 22.084 22.991
## 1951 22.964 23.981
## 1952 23.162 24.707
## 1953 25.246 25.180
## 1954 24.712 25.688
## 1955 25.693 26.881
## 1956 26.291 26.987
## 1957 26.634 27.735
## 1958 25.912 26.619
## 1959 26.992 27.897</code></pre>
<p>Функция <code>is.ts()</code> позволяет проверить, действительно ли
созданный нами объект birth.ts является временным рядом:</p>
<pre class="r"><code>is.ts(birth.ts)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>#[1] TRUE</code></pre>
<p>В R имеется достаточно большой набор методов для работы с объектами
класса ts. В частности, при помощи функции <code>plot()</code> можно
быстро изобразить временной ряд графически:</p>
<pre class="r"><code>plot(birth.ts, xlab = &quot;&quot;, ylab = &quot;Рождаемость, тыс. чел.&quot;)</code></pre>
<p><img src="typerdataM_files/figure-html/unnamed-chunk-87-1.png" width="672" /></p>
</div>
<div id="организация-вычислений-функции-ветвления-циклы"
class="section level1">
<h1>Организация вычислений: функции, ветвления, циклы</h1>
<p>Абсолютное большинство процедур обработки данных в R реализуется с
помощью функций. Функции представляют собой поименованный программный
код, состоящий из некоторого набора переменных, констант, операторов и
других функций, и предназначенный для выполнения конкретных операций и
задач.</p>
<p>Как правило (но не всегда), функции возвращают результат своего
выполнения в виде объекта языка R - переменной определенного класса:
вектора, списка, таблицы и т.д. По своему назначению функции можно
разделить на характерные группы: арифметические, символьные,
статистические и прочие.</p>
<p>Функции могут быть встроенными (т.е. представленными в базовых или
подгружаемых пакетах) и собственными (т.е. написанными непосредственно
самими пользователями). Некоторые наиболее употребительные встроенные
функции представлены ниже:</p>
<div id="арифметические-функции" class="section level2">
<h2>Арифметические функции</h2>
<table>
<colgroup>
<col width="54%" />
<col width="45%" />
</colgroup>
<thead>
<tr class="header">
<th>Вызов функции и описание</th>
<th>Пример и результат</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>abs(х)</code> - модуль величины <span
class="math inline">\(х\)</span></td>
<td><code>abs(-1)</code> -&gt; 1</td>
</tr>
<tr class="even">
<td><code>ceiling(х)</code> - округление до целого в большую
сторону</td>
<td><code>ceiling(9.435)</code> -&gt; 10</td>
</tr>
<tr class="odd">
<td><code>floor(х)</code> - округление до целого в меньшую сторону</td>
<td><code>floor(2.975)</code> -&gt; 2</td>
</tr>
<tr class="even">
<td><code>round (x, digits=n)</code> - округление до указанного числа
digits знаков после десятичной точки</td>
<td><code>round(5.475, 2)</code> -&gt; 5.48</td>
</tr>
<tr class="odd">
<td><code>signif(x, digits=n)</code> - округление до указанного числа
digits значащих цифр</td>
<td><code>signif(3.475, 2)</code> -&gt; 3.5</td>
</tr>
<tr class="even">
<td><code>trunc(x)</code> - округление до целого числа</td>
<td><code>trunc(4.99)</code> -&gt; 4</td>
</tr>
<tr class="odd">
<td><code>ехр(х)</code> - <span class="math inline">\(е^x\)</span></td>
<td><code>ехр(2.87)</code> -&gt; 17.637</td>
</tr>
<tr class="even">
<td><code>log(x)</code> - логарифм натуральный <span
class="math inline">\(х\)</span></td>
<td><code>log(3.12)</code> -&gt; 1.137</td>
</tr>
<tr class="odd">
<td><code>log10(x)</code> - логарифм десятичный <span
class="math inline">\(х\)</span></td>
<td><code>log(3.12)</code> -&gt; 0.494</td>
</tr>
<tr class="even">
<td><code>sqrt(x)</code> - корень квадратный <span
class="math inline">\(х\)</span></td>
<td><code>sqrt(2.12)</code> -&gt; 1.456</td>
</tr>
<tr class="odd">
<td><code>cos(x)</code>, <code>sin(x)</code>, <code>tan(x)</code>,
<code>acos(x</code>), <code>cosh(x)</code>, <code>acosh(x)</code> -
тригонометрические функции от <span
class="math inline">\(х\)</span></td>
<td><code>cos(1.27*pi)</code> -&gt; -0.661</td>
</tr>
</tbody>
</table>
</div>
<div id="функции-для-работы-с-символьными-типами-данных"
class="section level2">
<h2>Функции для работы с символьными типами данных</h2>
<table>
<colgroup>
<col width="60%" />
<col width="40%" />
</colgroup>
<thead>
<tr class="header">
<th>Вызов функции и описание</th>
<th>Пример и результат</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>grep(pattern,x,ignore.case=FALSE,fixed=FALSE)</code> - возврат
индекса первого найденного элемента pattern в <span
class="math inline">\(х\)</span></td>
<td><code>grep("A",c("x","y","A", "z"),fixed=TRUE)</code> –&gt; 3</td>
</tr>
<tr class="even">
<td><code>substr(x, start=nl, stop=n2)</code> - выбор или замена
символов в строках символьного вектора <span
class="math inline">\(х\)</span></td>
<td><code>substr("язык R", 2, 4)</code> –&gt; “зык”</td>
</tr>
<tr class="odd">
<td><code>paste(…, sep="")</code> - объединение символов или строк через
значение разделителя <code>sep</code></td>
<td><code>paste("x",l:3,sep="")</code> –&gt;“xl” “x2” “хЗ”</td>
</tr>
<tr class="even">
<td><code>strsplit(x, split)</code> - разделяет элементы вектора по
разделителям <code>split</code></td>
<td><code>strsplit("абв","")</code> –&gt;“а” “б” “в”</td>
</tr>
<tr class="odd">
<td><code>toupper(x)</code> и <code>tolower(x)</code> - преобразуют
буквы текстового вектора х в прописные и обратно</td>
<td><code>toupper("Man")</code> –&gt; “МАЛ” <code>toupper("EAn")</code>
–&gt; “бал”</td>
</tr>
</tbody>
</table>
<p>Примеры использования статистических функций приводятся в главе
4.</p>
</div>
</div>
<div id="написание-собственных-функций" class="section level1">
<h1>Написание собственных функций</h1>
<p>Тремя характерными чертами языка R как языка высокого уровня являются
модульность построения, ориентация на объекты, и векторизация
вычислений.</p>
<p>Под модульностью понимается широкое использование групп выражений и
функций.</p>
<p>Выражения <code>expr</code>, состоящие из объектов данных, вызовов
функций и других операторов языка могут группироваться в фигурных
скобках: <code>{expr_1;…; expr_m}</code>, и значение, которое возвращает
эта группа, представляет собой результат выполнения последнего
выражения. Поскольку такая группа является также выражением, то она
может быть, например, включена в круглые скобки и использоваться как
часть еще более общего выражения.</p>
<p>Например, группа команд ниже выполняет расчет среднего и стандартного
отклонения натурального ряда чисел от 1 до 10 и возвращает вектор из
этих значений:</p>
<pre class="r"><code>{aver &lt;- mean(1:10); 
stdev &lt;- sd(1:10); 
c(MEAN=aver, SD=stdev)} </code></pre>
<pre><code>##    MEAN      SD 
## 5.50000 3.02765</code></pre>
<p>Однако если этот расчет необходимо выполнить неоднократно для
различных наборов исходных данных, то его стоит оформить в виде функции.
Общий синтаксис оформления собственной функции пользователя таков:</p>
<blockquote>
<p><code>имя_функции &lt;- function(argl, arg2,...)  {</code>группа_выражений
return(object) }</p>
</blockquote>
<p>где имя_функции - имя создаваемой функции, <code>argl</code>,
<code>arg2</code>, … - формальные аргументы функции. Оператор return()
нужен в случаях, когда группа выражений не возвращает целевого
результата. Перед своим первым выполнением функция должна быть
определена в текущем скрипте, либо загружена с помощью команды source()
из скриптового файла, где она была предварительно подготовлена. Тогда
вызов функции может быть осуществлен как</p>
<blockquote>
<p><code>имя_функции (argl, arg2,…)</code></p>
</blockquote>
<p>где <code>argl</code>, <code>arg2</code>,… - фактические аргументы,
связанные с формальными параметрами функции по порядку их следования,
либо по наименованиям. Для представленного выше примера можно оформить
функцию:</p>
<pre class="r"><code>stat_param &lt;- function(x){
aver &lt;- mean(x); stdev &lt;- sd(x); c(MEAN=aver, SD=stdev)}</code></pre>
<p>и включить ее в коллекцию собственных функций, расположенных в файле
my_func.R. Тогда необходимый нам результат, приведенный выше, можно
получить, выполнив</p>
<pre class="r"><code>#source(&quot;my_func.R&quot;)
#stat_param (1:10)</code></pre>
<p>Компоненты списка аргументов в заголовке функций могут быть
обязательными или принимать опциональные значения. Например, следующая
функция возводит числовой объект <span class="math inline">\(x\)</span>
в степень <span class="math inline">\(n\)</span>, но если степень не
указана, то автоматически происходит возведение в куб:</p>
<pre class="r"><code>power &lt;- function(x,n = 3){ х^n }</code></pre>
<p>Аргументами функций могут быть объекты самого разного типа, например,
названия других функций. Так, следующая функция выполняет произвольные
преобразования случайных равномерно распределенных величин:</p>
<pre class="r"><code>my_exampl &lt;- function(n, func_trans)
{ x &lt;- runif(n) ; abs(func_trans(x)) }</code></pre>
<p>Тогда сгенерировать 5 прологарифмированных значений можно, если
записать:</p>
<pre class="r"><code>my_exampl(5, log)</code></pre>
<pre><code>## [1] 0.2417707 1.0814470 1.0732295 1.3589506 1.8105903</code></pre>
<pre class="r"><code>#[1] 0.6345459 0.6522557 2.4180118 0.1007311 1.6983938</code></pre>
</div>
<div id="условия-и-циклы" class="section level1">
<h1>Условия и циклы</h1>
<p>Как и в любом алгоритмическом языке, в R широко используются
ветвления и циклы вычислительного процесса. Условный оператор имеет
следующую структуру:</p>
<blockquote>
<p><code>if( логическое_выражение ){ группа_выражений_1 если логическое_выражение равно TRUE } else { группа_выражений_2 в противном случае }</code></p>
</blockquote>
<p>Например, следующая функция сравнивает размеры двух векторов:</p>
<pre class="r"><code>compare &lt;- function(x, y){ nl &lt;- length(x) ; n2 &lt;- length(y)
if(nl!= n2){
  if(nl &gt; n2){ z=(nl - n2)
   cat(&quot;Первый вектор имеет на &quot;,z,&quot; элементов 6ольше \n&quot;) } 
  else{ z=(n2 - nl)
   cat(&quot;Второй вектор имеет на &quot;,z,&quot; элементов 6ольше \n&quot;)}} else{cat(&quot;Количество элементов одинаково &quot;,nl,&quot;\n&quot;) } 
}</code></pre>
<pre class="r"><code>х &lt;- c(1:4)
у &lt;- c(1:9)
compare(х, у)</code></pre>
<pre><code>## Второй вектор имеет на  5  элементов 6ольше</code></pre>
<p>Первый вектор имеет на 5 элементов 6ольше Имеется также сокращенная
форма реализации ветвлений:</p>
<blockquote>
<p><code>ifelse(логическое выражение, группа выражений 1, группа выражений 2)</code></p>
</blockquote>
<p>Повторение в цикле одних и тех же вычислительных операций
осуществляется с использованием конструкций for(), while() или repeat(),
которые имеют следующий синтаксис:</p>
<blockquote>
<p>for (index in for_object) { группа_выражений }while
(логическое_выражение) { группа_выражений } `repeat { группа_выражений ;
break }</p>
</blockquote>
<p>Здесь объект <code>for_object</code> может быть вектором, массивом,
таблицей, или списком, а группа_выражений выполняется каждый раз для
каждого элемента <code>index</code> этого объекта. Рассмотрим в качестве
примера функцию оценки доверительного интервала среднего значения для
выборки размером n с использованием непараметрического бутстрепа.</p>
<p>Необходимо отметить, что устоявшегося перевода термина “bootstrap” с
английского языка на русский не существует. Используются разные
варианты: “бутстреп”, “бутстрэп”, “бутстрап”, “размножение выборок”,
“метод псевдовыборок” и даже “ресамплинг” (от англ. “resampling’”).
Несмотря на сложности с русскоязычным названием, суть метода, тем менее,
весьма проста и подробно изложена в оригинальных работах Б. Эфрона
(1979-1988). Бутстреп-метод с использованием R для решения различных
задач представлен в ряде монографий (Chernick, LaBudde, 2011; Zieffler
et al. 2011; Fox, Weisberg, 2012; Шитиков, Розенберг, 2014).</p>
<p>Предположим, что у нас есть выборка некоторого ограниченного объема,
и мы имеем основания полагать, что эта выборка является репрезентативной
(т.е. хорошо отражает свойства генеральной совокупности, из которой она
была взята). Идея бутстреп- метода заключается в том, что мы можем
рассматривать саму эту выборку в качестве “генеральной совокупности” и,
соответственно, можем извлечь большое число случайных выборок из этой
исходной совокупности для расчета интересующего нас параметра (или
параметров).</p>
<p>Очевидно, что благодаря случайному процессу формирования этих новых
выборок, будет наблюдаться определенная вариация значений оцениваемого
параметра. Другими словами, мы получим некоторое распределение значений
этого параметра. Рассчитав стандартное отклонение этого распределения,
мы получим оценку стандартной ошибки параметра, которая при большом
числе наблюдений будет асимптотически приближаться к истинной
стандартной ошибке. Аналогично можно получить оценки границ
доверительного интервала. Итак, будем генерировать из исходной выборки
множество псевдовыборок того же размера, состоящих из случайных
комбинаций исходного набора элементов.</p>
<p>При этом используем алгоритм “случайного выбора с возвратом” (random
sampling with replacement), т.е. извлеченный элемент возвращается в
исходную совокупность и имеет шанс быть выбранным снова. В результате
некоторые члены в каждой отдельной псевдовыборке могут повторяться два
или более раз, тогда как другие - отсутствовать.</p>
<p>Этот алгоритм в R реализован в функции
<code>sample(data,replace=T)</code>. Для каждой псевдовыборки мы
рассчитаем значение среднего, а в качестве границ 95%-ного
доверительного интервала (bootstrap percentile interval) примем 2.5% и
97.5% квантили бутстреп-распределения:</p>
<pre class="r"><code>boot_np &lt;- function(data , Nboot=5000) {
 boots &lt;- numeric(Nboot) # Пустой вектор для хранения результатов 
for (i in 1:Nboot) { boots[i] &lt;- mean(sample(data,replace=T)) }
CI &lt;- quantile(boots, prob=c(0.025,0.975)) 
return (c(m = mean(data),CI))
}
x &lt;-c(5, 5, 8, 10, 10, 10, 19, 20, 20, 20, 30, 40, 42, 50, 50)
boot_np(x)</code></pre>
<pre><code>##        m     2.5%    97.5% 
## 22.60000 15.39833 30.66667</code></pre>
<pre class="r"><code>#m 2.5% 97.5%
#22.6 15.0 30.8</code></pre>
<p>Здесь конструкция <code>for()</code> осуществляет формирование Nboot
= 5000 значений средних для генерируемых псевдовыборок. Покажем,
пользуясь случаем, как можно оценить выборочный доверительный интервал
обычным параметрическим методом на основе процентилей распределения
Стьюдента:</p>
<pre class="r"><code>param_CI &lt;- function(data) {
n = length(data) ; m = mean(data)
SE = sd(data)/sqrt(n); E = qt(.975, df=n-1)*SE
CI &lt;- m + c(-E, E)
return (c(m , CI))
}
param_CI(x)</code></pre>
<pre><code>## [1] 22.60000 13.74741 31.45259</code></pre>
<pre class="r"><code>#[1] 22.6  13.74741  31.45259</code></pre>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
